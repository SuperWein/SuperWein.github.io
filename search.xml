<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>你真的了解java线程池吗?</title>
      <link href="/2021/02/05/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%97/"/>
      <url>/2021/02/05/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="你真的了解java线程池吗"><a href="#你真的了解java线程池吗" class="headerlink" title="你真的了解java线程池吗?"></a>你真的了解java线程池吗?</h2><blockquote><p><strong>说道juc提供java线程池，想必大家都不陌生，在很多异步场景、任务调度都会使用到它，但是很多人并不太理解线程池的实现原理，就在昨天看到一个在学习线程池的同学遇到了一个问题，通过Executors类的newFixedThreadPool(int nThreads)方法创建了一个固定大小的线程池，最大worker工作线程数量是3，然后创建了一百个任务提交到线程池，运行之后却没有触发默认线程池饱和策略AbortPolicy？？？答案当然是肯定不会触发了，如果阅读过创建固定线程池的源码肯定就不会这么问了，话不多说，上干货。</strong></p></blockquote><h3 id="合理使用java线程池的好处"><a href="#合理使用java线程池的好处" class="headerlink" title="合理使用java线程池的好处"></a>合理使用java线程池的好处</h3><p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p><p>第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。</p><h3 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h3><p>当我们向线程池中commit一个任务之后，线程池是如何处理这个任务的呢？</p><ul><li>线程池首先会判断核心线程池里的线程是否都在执行任务，如果不是，则创建一个新的工作线程。如果核心线程池里的线程都在执行任务，则进入下个流程。</li><li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新commit的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li><li>线程池判断线程池里的线程是否都处于工作状态。如果不是，则创建一个新的工作线程来执行任务。如果线程池已经满了，则交给饱和策略来处理这个任务。<br><a href="https://img-blog.csdnimg.cn/20210205131419696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E1MjUzOTA4MDI=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20210205131419696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E1MjUzOTA4MDI=,size_16,color_FFFFFF,t_70" class="lazyload"></a><br><strong>图1 线程的主要处理流程</strong></li></ul><p>看完上面讲解的线程池处理commit任务的流程之后，相信你已经对线程池的设计有了新的认识和理解，那么接下来重点讲一下JUC里面ThreadPoolExecutor执行execute方法分下面4种情况：</p><ul><li>如果当前线程池中运行的线程少于corePoolSize，那么创建新线程来执行任务（注意：执行这一步骤需要获取全局锁，保证线程安全）。</li><li>如果当前线程池中运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue任务队列（阻塞队列）。</li><li>如果线程池无法将任务加入BlockingQueue，此时队列已满，则需要创建新的线程来处理任务（注意：执行这一步骤需要获取全局锁，保证线程安全）。</li><li>如果当前运行的线程数超出maximumPoolSize，任务将被拒绝，将会出发线程池饱和策略，调用RejectedExecutionHandler.rejectedExecution()方法。</li></ul><p>ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。<br><a href="https://img-blog.csdnimg.cn/20210205131419701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E1MjUzOTA4MDI=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20210205131419701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E1MjUzOTA4MDI=,size_16,color_FFFFFF,t_70" class="lazyload"></a><br> <strong>图2 ThreadPoolExecutor执行示意图</strong></p><p>源码分析：上面的流程分析让我们很直观地了解了线程池的工作原理，接下再通过源代码来看看线程池是如何实现的，线程池执行任务的方法如下。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123; </span><br><span class="line">   <span class="keyword">if</span> (command == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); </span><br><span class="line">   <span class="comment">// 如果线程数小于基本线程数，则创建线程并执行当前任务 </span></span><br><span class="line">   <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123; </span><br><span class="line">       <span class="comment">// 如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。</span></span><br><span class="line">       <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123; </span><br><span class="line">           <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>) </span><br><span class="line">               ensureQueuedTaskHandled(command); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量， </span></span><br><span class="line">            <span class="comment">// 则创建一个线程执行任务。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command)) </span><br><span class="line">                <span class="comment">// 抛出RejectedExecutionException异常 </span></span><br><span class="line">                reject(command); <span class="comment">// is shutdown or saturated </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>线程池创建新线程时，会将线程封装成工作线程Worker，在执行完任务后，还会循环获取工作队列里的任务来执行。我们可以从Worker类的run()方法里看到这点（线程池创建新线程执行任务时，会直接交给当前创建的线程处理。任务执行完之后，会反复从任务队列里面获取任务来执行）。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       Runnable task = firstTask; firstTask = <span class="keyword">null</span>; </span><br><span class="line">       <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123; </span><br><span class="line">           runTask(task);</span><br><span class="line">           task = <span class="keyword">null</span>; </span><br><span class="line">      &#125; </span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">       workerDone(<span class="keyword">this</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="线程池饱和策略"><a href="#线程池饱和策略" class="headerlink" title="线程池饱和策略"></a>线程池饱和策略</h3><p>当任务队列和线程池都满了，此时线程池处于饱和状态，那么我们必须采取一种策略处理提交的新任务。默认的线程池饱和策略是AbortPolicy，当无法处理新任务时会直接抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略：</p><ul><li>AbortPolicy：线程池饱和后，提交任务时直接抛出异常。</li><li>CallerRunsPolicy：新提交的任务将在调用者所在线程来执行。</li><li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前提交的任务。</li><li>DiscardPolicy：新提交的任务不处理，直接丢弃。</li></ul><p>可以根据实际场景来设置不同的饱和策略，不太重要的任务，可以使用默认线程池策略或者不处理。另外任务较多，并且任务处理时间较长，任务队列也会暂用过多内存，也要合理控制。</p><h3 id="线程池构造参数详解"><a href="#线程池构造参数详解" class="headerlink" title="线程池构造参数详解"></a>线程池构造参数详解</h3><p>这里通过ThreadPoolExecutor的构造方法来手动创建线程池，如果我们想要合理的使用线程池，还是必须要对构造参数了解一下。</p><ul><li>corePoolSize（核心线程池的大小）：当向线程池中commit一个任务到时，如果线程池中的线程数小于核心线程池的大小，线程池会创建一个新的线程来执行任务，即使其他的核心线程处于空闲状态，直到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池在创建的时候会提前创建并启动所有核心线程，称为“线程池预热”。</li><li>runnableTaskQueue（任务队列）：用来保存提交的等待执行的任务，该队列采用的是阻塞队列（生产者和消费者模式）。</li><li>ThreadFactory：用来设置创建线程的工厂，通过线程工厂可以给每个创建出来的线程设置名称，方便问题排查。线程工厂的创建推荐使用谷歌开源框架guava框架提供的ThreadFactoryBuilder类，可以快速创建线程工厂对象，示例如下；new ThreadFactoryBuilder().setNameFormat(“XXXX-task-%d”).build();</li><li>keepAliveTime（线程活动保持时间）：指的是线程池的worker线程空闲后，保持存活的时间。如果任务相对较多，并且满足每个任务执行的时间较短，适当调大keepAlive时间，可以提高线程的利用率，不会频繁的创建和销毁线程。</li><li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。3）maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。<h4 id="线程池构任务队列可选类"><a href="#线程池构任务队列可选类" class="headerlink" title="线程池构任务队列可选类"></a>线程池构任务队列可选类</h4></li><li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原 则对元素进行排序。</li><li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列</li><li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li></ul><h3 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h3><p>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线 程。</p><p>只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务 都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪 一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭 线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p><blockquote><p>更多关于线程池的文章，线程池的合理配置和线程池监控将在下一篇文章中讲解，敬请期待…<br>参考：《Java并发编程的艺术》</p></blockquote><p><a href="https://img-blog.csdnimg.cn/20210205132408811.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20210205132408811.png#pic_center" class="lazyload"></a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程基础</title>
      <link href="/2020/03/12/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/03/12/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Java多线程基础"><a href="#Java多线程基础" class="headerlink" title="Java多线程基础"></a>Java多线程基础</h2><p>###　线程的出现</p><ul><li>线程可以认为是轻量级的进程，所以线程的创建、销毁比进程更快</li><li>在多核CPU中，利用多线程可以实现真正意义的并行执行（单核cpu中线程是通过cpu时间片不断切换执行的，在任意时刻只会有一个线程会被cpu调度）</li><li>在一个应用进程中，会存在多个同时执行的任务，如果其中一个任务被阻塞，将会导致其他任务也会被阻塞。通过对不同任务创建不同的线程去处理，可以提升程序的实时性</li></ul><h3 id="线程生命周期-6种状态"><a href="#线程生命周期-6种状态" class="headerlink" title="线程生命周期(6种状态)"></a>线程生命周期(6种状态)</h3><p>NEW、RUNNABLE、BLOCKED、WAITING、TIME_WAITING、TERMINATED（详情见Thread源码）</p><ul><li>NEW：初始状态，线程，但是还没有调用线程的start方法</li><li>RUNNABLE：运行状态，JAVA把操作系统中线程的就绪和运行两种状态统一称为“运行中”</li><li>BLOCKED：阻塞状态，表示线程进入等待状态，线程因为某种原因放弃了CPU使用权，阻塞分以下几种情况<ul><li>等待阻塞：运行的线程执行wait方法（<strong>只有获得锁，才能执行wait方法</strong>），jvm会把当前的线程放入到等待队列</li><li>同步阻塞：运行的线程在获取对象的同步锁时，如果该同步锁被其他线程占用了，那么jvm会把当前线程放入到锁池中</li><li>其他阻塞：运行的线程执行了Thread.sleep或者join方法，或者<code>发出了IO请求</code>时，jvm会帮当前线程设置为阻塞状态，当sleep结束、join线程终止、io处理完毕，线程恢复</li><li>TIME_WAITING：超时等待状态，超时后自动返回</li><li>TERMINATED：终止状态，表示当前线程执行完毕</li></ul></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A thread state.  A thread can be in one of the following states:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@link</span> #NEW&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *     A thread that has not yet started is in this state.</span></span><br><span class="line"><span class="comment"> *     &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@link</span> #RUNNABLE&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *     A thread executing in the Java virtual machine is in this state.</span></span><br><span class="line"><span class="comment"> *     &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@link</span> #BLOCKED&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *     A thread that is blocked waiting for a monitor lock</span></span><br><span class="line"><span class="comment"> *     is in this state.</span></span><br><span class="line"><span class="comment"> *     &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@link</span> #WAITING&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *     A thread that is waiting indefinitely for another thread to</span></span><br><span class="line"><span class="comment"> *     perform a particular action is in this state.</span></span><br><span class="line"><span class="comment"> *     &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@link</span> #TIMED_WAITING&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *     A thread that is waiting for another thread to perform an action</span></span><br><span class="line"><span class="comment"> *     for up to a specified waiting time is in this state.</span></span><br><span class="line"><span class="comment"> *     &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@link</span> #TERMINATED&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *     A thread that has exited is in this state.</span></span><br><span class="line"><span class="comment"> *     &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * A thread can be in only one state at a given point in time.</span></span><br><span class="line"><span class="comment"> * These states are virtual machine states which do not reflect</span></span><br><span class="line"><span class="comment"> * any operating system thread states.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getState</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  NEW,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">   * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">   * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">   * such as processor.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  RUNNABLE,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">   * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">   * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">   * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  BLOCKED,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">   * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">   * following methods:</span></span><br><span class="line"><span class="comment">   * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">   *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">   * perform a particular action.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">   * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">   * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">   * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">   * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  WAITING,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">   * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">   * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">   * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">   *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">   * The thread has completed execution.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>查看线程的状态及jvm内存监控可以参考以下命令：</p><ul><li><p><a href="http://www.hollischuang.com/archives/105" target="_blank" rel="noopener">jps</a>:查看本机的Java中进程信息</p></li><li><p><a href="http://www.hollischuang.com/archives/110" target="_blank" rel="noopener">jstack</a>:打印线程的栈信息,制作线程Dump（jstack pid&lt;进程id&gt;）</p></li><li><p><a href="http://www.hollischuang.com/archives/303" target="_blank" rel="noopener">jmap</a>:打印内存映射,制作堆Dump（jmap -dump:format-b,file=保存文件路径）</p></li><li><p><a href="http://www.hollischuang.com/archives/481" target="_blank" rel="noopener">jstat</a>:性能监控工具</p></li><li><p><a href="http://www.hollischuang.com/archives/1047" target="_blank" rel="noopener">jhat</a>:内存分析工具 jhat -port file&lt;dump文件&gt;</p></li><li><p>jconsole:简易的可视化控制台</p></li><li><p>jvisualvm:功能强大的控制台</p></li></ul><h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><ul><li>继承Thread类（本质是对Runnable接口的实现）</li><li>实现Runnable接口</li><li>使用ExecutorService</li><li>Callable、Future（带返回值）</li></ul><p>启动线程的唯一方法就是通过Thread类的start方法（srart方法是一个native方法，它会启动一个新的线程，并执行run方法）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Thread class source code */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Make sure registerNatives is the first thing &lt;clinit&gt; does. */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    registerNatives();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* What will be run. */</span></span><br><span class="line">  <span class="keyword">private</span> Runnable target;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target, String name)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, name, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is not invoked for the main method thread or "system"</span></span><br><span class="line"><span class="comment">     * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">     * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A zero status value corresponds to state "NEW".</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">     * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">     * and the group's unstarted count can be decremented. */</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      start0();</span><br><span class="line">      started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">          group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">        <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">             it will be passed up the call stack */</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** native method */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">      target.run();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="jvm线程创建、启动源码"><a href="#jvm线程创建、启动源码" class="headerlink" title="jvm线程创建、启动源码"></a>jvm线程创建、启动源码</h4><p>打开<a href="http://hg.openjdk.java.net/" target="_blank" rel="noopener">OpenJDK</a> / <a href="http://hg.openjdk.java.net/jdk8" target="_blank" rel="noopener">jdk8</a> / <a href="http://hg.openjdk.java.net/jdk8/jdk8" target="_blank" rel="noopener">jdk8</a> / <a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk" target="_blank" rel="noopener">jdk</a>源码，找到文件-&gt;<a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/00cd9dc3c2b5/src/share/native/java/lang/Thread.c" target="_blank" rel="noopener">src/share/native/java/lang/Thread.c @ 2362:00cd9dc3c2b5</a>，可以看到java中Thread类中调用的本地方法，在虚拟机jvm.cpp文件中的定义，以及映射关系，本地方法通过JNI技术暴露给外部调用。</p><p>Thread.c文件源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"jni.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"jvm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"java_lang_Thread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THD <span class="meta-string">"Ljava/lang/Thread;"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ <span class="meta-string">"Ljava/lang/Object;"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STE <span class="meta-string">"Ljava/lang/StackTraceElement;"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_LENGTH(a) (sizeof(a)/sizeof(a[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">"start0"</span>,           <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_StartThread&#125;,</span><br><span class="line">    &#123;<span class="string">"stop0"</span>,            <span class="string">"("</span> OBJ <span class="string">")V"</span>, (<span class="keyword">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    &#123;<span class="string">"isAlive"</span>,          <span class="string">"()Z"</span>,        (<span class="keyword">void</span> *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class="line">    &#123;<span class="string">"suspend0"</span>,         <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_SuspendThread&#125;,</span><br><span class="line">    &#123;<span class="string">"resume0"</span>,          <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_ResumeThread&#125;,</span><br><span class="line">    &#123;<span class="string">"setPriority0"</span>,     <span class="string">"(I)V"</span>,       (<span class="keyword">void</span> *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class="line">    &#123;<span class="string">"yield"</span>,            <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_Yield&#125;,</span><br><span class="line">    &#123;<span class="string">"sleep"</span>,            <span class="string">"(J)V"</span>,       (<span class="keyword">void</span> *)&amp;JVM_Sleep&#125;,</span><br><span class="line">    &#123;<span class="string">"currentThread"</span>,    <span class="string">"()"</span> THD,     (<span class="keyword">void</span> *)&amp;JVM_CurrentThread&#125;,</span><br><span class="line">    &#123;<span class="string">"countStackFrames"</span>, <span class="string">"()I"</span>,        (<span class="keyword">void</span> *)&amp;JVM_CountStackFrames&#125;,</span><br><span class="line">    &#123;<span class="string">"interrupt0"</span>,       <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">    &#123;<span class="string">"isInterrupted"</span>,    <span class="string">"(Z)Z"</span>,       (<span class="keyword">void</span> *)&amp;JVM_IsInterrupted&#125;,</span><br><span class="line">    &#123;<span class="string">"holdsLock"</span>,        <span class="string">"("</span> OBJ <span class="string">")Z"</span>, (<span class="keyword">void</span> *)&amp;JVM_HoldsLock&#125;,</span><br><span class="line">    &#123;<span class="string">"getThreads"</span>,        <span class="string">"()["</span> THD,   (<span class="keyword">void</span> *)&amp;JVM_GetAllThreads&#125;,</span><br><span class="line">    &#123;<span class="string">"dumpThreads"</span>,      <span class="string">"(["</span> THD <span class="string">")[["</span> STE, (<span class="keyword">void</span> *)&amp;JVM_DumpThreads&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> THD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> OBJ</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> STE</span></span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_lang_Thread_registerNatives(JNIEnv *env, jclass cls)</span><br><span class="line">&#123;</span><br><span class="line">    (*env)-&gt;RegisterNatives(env, cls, methods, ARRAY_LENGTH(methods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>/src/share/vm/prims/jvm.cpp源码（线程启动）：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_StartThread(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_StartThread"</span>);</span><br><span class="line">  JavaThread *native_thread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We cannot hold the Threads_lock when we throw an exception,</span></span><br><span class="line">  <span class="comment">// due to rank ordering issues. Example:  we might need to grab the</span></span><br><span class="line">  <span class="comment">// Heap_lock while we construct the exception.</span></span><br><span class="line">  <span class="keyword">bool</span> throw_illegal_thread_state = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We must release the Threads_lock before we can post a jvmti event</span></span><br><span class="line">  <span class="comment">// in Thread::start.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Ensure that the C++ Thread and OSThread structures aren't freed before</span></span><br><span class="line">    <span class="comment">// we operate.</span></span><br><span class="line">    <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since JDK 5 the java.lang.Thread threadStatus is used to prevent</span></span><br><span class="line">    <span class="comment">// re-starting an already started thread, so we should usually find</span></span><br><span class="line">    <span class="comment">// that the JavaThread is null. However for a JNI attached thread</span></span><br><span class="line">    <span class="comment">// there is a small window between the Thread object being created</span></span><br><span class="line">    <span class="comment">// (with its JavaThread set) and the update to its threadStatus, so we</span></span><br><span class="line">    <span class="comment">// have to check for this</span></span><br><span class="line">    <span class="keyword">if</span> (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      throw_illegal_thread_state = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// We could also check the stillborn flag to see if this thread was already stopped, but</span></span><br><span class="line">      <span class="comment">// for historical reasons we let the thread detect that itself when it starts running</span></span><br><span class="line"></span><br><span class="line">      jlong <span class="built_in">size</span> =</span><br><span class="line">             java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">      <span class="comment">// Allocate the C++ Thread structure and create the native thread.  The</span></span><br><span class="line">      <span class="comment">// stack size retrieved from java is signed, but the constructor takes</span></span><br><span class="line">      <span class="comment">// size_t (an unsigned type), so avoid passing negative values which would</span></span><br><span class="line">      <span class="comment">// result in really large stacks.</span></span><br><span class="line">      <span class="keyword">size_t</span> sz = <span class="built_in">size</span> &gt; <span class="number">0</span> ? (<span class="keyword">size_t</span>) <span class="built_in">size</span> : <span class="number">0</span>;</span><br><span class="line">      native_thread = <span class="keyword">new</span> JavaThread(&amp;thread_entry, sz);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// At this point it may be possible that no osthread was created for the</span></span><br><span class="line">      <span class="comment">// JavaThread due to lack of memory. Check for this situation and throw</span></span><br><span class="line">      <span class="comment">// an exception if necessary. Eventually we may want to change this so</span></span><br><span class="line">      <span class="comment">// that we only grab the lock if the thread was created successfully -</span></span><br><span class="line">      <span class="comment">// then we can also do this check and throw the exception in the</span></span><br><span class="line">      <span class="comment">// JavaThread constructor.</span></span><br><span class="line">      <span class="keyword">if</span> (native_thread-&gt;osthread() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// Note: the current thread is not being used within "prepare".</span></span><br><span class="line">        native_thread-&gt;<span class="built_in">prepare</span>(jthread);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (throw_illegal_thread_state) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_IllegalThreadStateException());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(native_thread != <span class="literal">NULL</span>, <span class="string">"Starting null thread?"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (native_thread-&gt;osthread() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// No one should hold a reference to the 'native_thread'.</span></span><br><span class="line">    <span class="keyword">delete</span> native_thread;</span><br><span class="line">    <span class="keyword">if</span> (JvmtiExport::should_post_resource_exhausted()) &#123;</span><br><span class="line">      JvmtiExport::post_resource_exhausted(</span><br><span class="line">        JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,</span><br><span class="line">        <span class="string">"unable to create new native thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),</span><br><span class="line">              <span class="string">"unable to create new native thread"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Thread::start(native_thread);</span><br><span class="line"></span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure></div><p>从源码native_thread = new JavaThread(&amp;thread_entry, sz);可以看出，本地线程native_thread是通过创建JAVA线程来创建的，通过Thread::start(native_thread)来启动线程，最终通过操作系统来创建线程。</p><p>/src/share/vm/runtime/thread.cpp源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::start</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  trace(<span class="string">"start"</span>, thread);</span><br><span class="line">  <span class="comment">// Start is different from resume in that its safety is guaranteed by context or</span></span><br><span class="line">  <span class="comment">// being called from a Java method synchronized on the Thread object.</span></span><br><span class="line">  <span class="keyword">if</span> (!DisableStartThread) &#123;</span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;is_Java_thread()) &#123;</span><br><span class="line">      <span class="comment">// Initialize the thread state to RUNNABLE before starting this thread.</span></span><br><span class="line">      <span class="comment">// Can not set it after the thread started because we do not know the</span></span><br><span class="line">      <span class="comment">// exact thread state at that time. It could be in MONITOR_WAIT or</span></span><br><span class="line">      <span class="comment">// in SLEEPING or some other state.</span></span><br><span class="line">      java_lang_Thread::set_thread_status(((JavaThread*)thread)-&gt;threadObj(),</span><br><span class="line">                                          java_lang_Thread::RUNNABLE);</span><br><span class="line">    &#125;</span><br><span class="line">    os::start_thread(thread);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="jvm中断线程方法"><a href="#jvm中断线程方法" class="headerlink" title="jvm中断线程方法"></a>jvm中断线程方法</h3><p>/src/share/vm/prims/jvm.cpp源码，jvm最后调用Thread.cpp中的is_interrupted方法去中断某个线程</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_Interrupt(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_Interrupt"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that the C++ Thread and OSThread structures aren't freed before we operate</span></span><br><span class="line">  oop java_thread = JNIHandles::resolve_non_null(jthread);</span><br><span class="line">  <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(thread-&gt;threadObj() == java_thread ? <span class="literal">NULL</span> : Threads_lock)</span></span>;</span><br><span class="line">  <span class="comment">// We need to re-resolve the java_thread, since a GC might have happened during the</span></span><br><span class="line">  <span class="comment">// acquire of the lock</span></span><br><span class="line">  JavaThread* thr = java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">  <span class="keyword">if</span> (thr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    Thread::interrupt(thr);</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br><span class="line"></span><br><span class="line">JVM_QUICK_ENTRY(jboolean, JVM_IsInterrupted(JNIEnv* env, jobject jthread, jboolean clear_interrupted))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_IsInterrupted"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that the C++ Thread and OSThread structures aren't freed before we operate</span></span><br><span class="line">  oop java_thread = JNIHandles::resolve_non_null(jthread);</span><br><span class="line">  <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(thread-&gt;threadObj() == java_thread ? <span class="literal">NULL</span> : Threads_lock)</span></span>;</span><br><span class="line">  <span class="comment">// We need to re-resolve the java_thread, since a GC might have happened during the</span></span><br><span class="line">  <span class="comment">// acquire of the lock</span></span><br><span class="line">  JavaThread* thr = java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">  <span class="keyword">if</span> (thr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (jboolean) Thread::is_interrupted(thr, clear_interrupted != <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure></div><p>/src/share/vm/runtime/thread.cpp源码，最终是调用操作系统的is_interrupted方法中断线程</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::interrupt</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  trace(<span class="string">"interrupt"</span>, thread);</span><br><span class="line">  debug_only(check_for_dangling_thread_pointer(thread);)</span><br><span class="line">  os::interrupt(thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Thread::is_interrupted</span><span class="params">(Thread* thread, <span class="keyword">bool</span> clear_interrupted)</span> </span>&#123;</span><br><span class="line">  trace(<span class="string">"is_interrupted"</span>, thread);</span><br><span class="line">  debug_only(check_for_dangling_thread_pointer(thread);)</span><br><span class="line">  <span class="comment">// Note:  If clear_interrupted==false, this simply fetches and</span></span><br><span class="line">  <span class="comment">// returns the value of the field osthread()-&gt;interrupted().</span></span><br><span class="line">  <span class="keyword">return</span> os::is_interrupted(thread, clear_interrupted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>/src/os/linux/vm/os_linux.cpp源代码（这里已linux操作系统平台为例），通过调用OSThread类的set_interrupted(true)，将成员变量_interrupted设置为true，来设置线程中断，默认为false</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">os::interrupt</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  assert(Thread::current() == thread || Threads_lock-&gt;owned_by_self(),</span><br><span class="line">    <span class="string">"possibility of dangling Thread pointer"</span>);</span><br><span class="line"></span><br><span class="line">  OSThread* osthread = thread-&gt;osthread();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!osthread-&gt;interrupted()) &#123;</span><br><span class="line">    osthread-&gt;set_interrupted(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// More than one thread can get here with the same value of osthread,</span></span><br><span class="line">    <span class="comment">// resulting in multiple notifications.  We do, however, want the store</span></span><br><span class="line">    <span class="comment">// to interrupted() to be visible to other threads before we execute unpark().</span></span><br><span class="line">    OrderAccess::fence();</span><br><span class="line">    ParkEvent * <span class="keyword">const</span> slp = thread-&gt;_SleepEvent ;</span><br><span class="line">    <span class="keyword">if</span> (slp != <span class="literal">NULL</span>) slp-&gt;unpark() ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For JSR166. Unpark even if interrupt status already was set</span></span><br><span class="line">  <span class="keyword">if</span> (thread-&gt;is_Java_thread())</span><br><span class="line">    ((JavaThread*)thread)-&gt;parker()-&gt;unpark();</span><br><span class="line"></span><br><span class="line">  ParkEvent * ev = thread-&gt;_ParkEvent ;</span><br><span class="line">  <span class="keyword">if</span> (ev != <span class="literal">NULL</span>) ev-&gt;unpark() ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">os::is_interrupted</span><span class="params">(Thread* thread, <span class="keyword">bool</span> clear_interrupted)</span> </span>&#123;</span><br><span class="line">  assert(Thread::current() == thread || Threads_lock-&gt;owned_by_self(),</span><br><span class="line">    <span class="string">"possibility of dangling Thread pointer"</span>);</span><br><span class="line"></span><br><span class="line">  OSThread* osthread = thread-&gt;osthread();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> interrupted = osthread-&gt;interrupted();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (interrupted &amp;&amp; clear_interrupted) &#123;</span><br><span class="line">    osthread-&gt;set_interrupted(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// consider thread-&gt;_SleepEvent-&gt;reset() ... optional optimization</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> interrupted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>/src/share/vm/runtime/osThread.hpp源代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OSThread</span>:</span> <span class="keyword">public</span> CHeapObj&lt;mtThread&gt; &#123;</span><br><span class="line"> <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span>;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/** 省略其他代码 */</span></span><br><span class="line">  <span class="keyword">volatile</span> ThreadState _state;    <span class="comment">// Thread state *hint*</span></span><br><span class="line">  <span class="keyword">volatile</span> jint _interrupted;     <span class="comment">// Thread.isInterrupted state</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note:  _interrupted must be jint, so that Java intrinsics can access it.</span></span><br><span class="line">  <span class="comment">// The value stored there must be either 0 or 1.  It must be possible</span></span><br><span class="line">  <span class="comment">// for Java to emulate Thread.currentThread().isInterrupted() by performing</span></span><br><span class="line">  <span class="comment">// the double indirection Thread::current()-&gt;_osthread-&gt;_interrupted.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Methods</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_state</span><span class="params">(ThreadState state)</span>                </span>&#123; _state = state; &#125;</span><br><span class="line">  <span class="function">ThreadState <span class="title">get_state</span><span class="params">()</span>                          </span>&#123; <span class="keyword">return</span> _state; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 省略其他代码 */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">volatile</span> <span class="keyword">bool</span> <span class="title">interrupted</span><span class="params">()</span> <span class="keyword">const</span>                 </span>&#123; <span class="keyword">return</span> _interrupted != <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_interrupted</span><span class="params">(<span class="keyword">bool</span> z)</span>                      </span>&#123; _interrupted = z ? <span class="number">1</span> : <span class="number">0</span>; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** ....... 剩余代码省略 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="线程Interrupte之后调用Thread-interrupted-复位"><a href="#线程Interrupte之后调用Thread-interrupted-复位" class="headerlink" title="线程Interrupte之后调用Thread.interrupted()复位"></a>线程Interrupte之后调用Thread.interrupted()复位</h4><p>Thread.java</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread.interrupted();  <span class="comment">// 复位，回到初始状态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地方法，参考上面已经提到的jvm线程中断源码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure></div><blockquote><p><strong>中断一个处于阻塞状态(sleep/wait/join/…)的线程，会先复位，再抛出异常（为什么会抛出异常可以参考jvm.cpp文件中的JVM_Sleep方法）</strong></p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong <span class="built_in">millis</span>))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_Sleep"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">millis</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), <span class="string">"timeout value is negative"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Thread::is_interrupted (THREAD, <span class="literal">true</span>) &amp;&amp; !HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">    THROW_MSG(vmSymbols::java_lang_InterruptedException(), <span class="string">"sleep interrupted"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save current thread state and restore it at the end of this block.</span></span><br><span class="line">  <span class="comment">// And set new thread state to SLEEPING.</span></span><br><span class="line">  <span class="function">JavaThreadSleepState <span class="title">jtss</span><span class="params">(thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> USDT2</span></span><br><span class="line">  HS_DTRACE_PROBE1(hotspot, thread__sleep__begin, <span class="built_in">millis</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">  HOTSPOT_THREAD_SLEEP_BEGIN(</span><br><span class="line">                             <span class="built_in">millis</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line"></span><br><span class="line">  EventThreadSleep event;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">millis</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// When ConvertSleepToYield is on, this matches the classic VM implementation of</span></span><br><span class="line">    <span class="comment">// JVM_Sleep. Critical for similar threading behaviour (Win32)</span></span><br><span class="line">    <span class="comment">// It appears that in certain GUI contexts, it may be beneficial to do a short sleep</span></span><br><span class="line">    <span class="comment">// for SOLARIS</span></span><br><span class="line">    <span class="keyword">if</span> (ConvertSleepToYield) &#123;</span><br><span class="line">      os::<span class="built_in">yield</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ThreadState old_state = thread-&gt;osthread()-&gt;get_state();</span><br><span class="line">      thread-&gt;osthread()-&gt;set_state(SLEEPING);</span><br><span class="line">      os::sleep(thread, MinSleepInterval, <span class="literal">false</span>);</span><br><span class="line">      thread-&gt;osthread()-&gt;set_state(old_state);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ThreadState old_state = thread-&gt;osthread()-&gt;get_state();</span><br><span class="line">    thread-&gt;osthread()-&gt;set_state(SLEEPING);</span><br><span class="line">    <span class="keyword">if</span> (os::sleep(thread, <span class="built_in">millis</span>, <span class="literal">true</span>) == OS_INTRPT) &#123;</span><br><span class="line">      <span class="comment">// An asynchronous exception (e.g., ThreadDeathException) could have been thrown on</span></span><br><span class="line">      <span class="comment">// us while we were sleeping. We do not overwrite those.</span></span><br><span class="line">      <span class="keyword">if</span> (!HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.should_commit()) &#123;</span><br><span class="line">          event.set_time(<span class="built_in">millis</span>);</span><br><span class="line">          event.commit();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> USDT2</span></span><br><span class="line">        HS_DTRACE_PROBE1(hotspot, thread__sleep__end,<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">        HOTSPOT_THREAD_SLEEP_END(</span><br><span class="line">                                 <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">        <span class="comment">// TODO-<span class="doctag">FIXME:</span> THROW_MSG returns which means we will not call set_state()</span></span><br><span class="line">        <span class="comment">// to properly restore the thread state.  That's likely wrong.</span></span><br><span class="line">        THROW_MSG(vmSymbols::java_lang_InterruptedException(), <span class="string">"sleep interrupted"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread-&gt;osthread()-&gt;set_state(old_state);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (event.should_commit()) &#123;</span><br><span class="line">    event.set_time(<span class="built_in">millis</span>);</span><br><span class="line">    event.commit();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> USDT2</span></span><br><span class="line">  HS_DTRACE_PROBE1(hotspot, thread__sleep__end,<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">  HOTSPOT_THREAD_SLEEP_END(</span><br><span class="line">                           <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure></div><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><ul><li>线程池</li><li>zookeeper责任链，异步化任务</li><li>跑批脚本、对账文件</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/03/12/hello-world/"/>
      <url>/2020/03/12/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
